import 'dart:convert';
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../config.dart';
import '../models/http_exception.dart';
import 'package:http/http.dart' as http;

class PlanItem {
  final String category;
  final String task;
  final String priority;
  final bool done;
  final int startTimeH;
  final int startTimeM;
  final int endTimeH;
  final int endTimeM;

  PlanItem(
      {@required this.category,
      @required this.task,
      @required this.priority,
      @required this.done,
      @required this.startTimeH,
      @required this.startTimeM,
      @required this.endTimeH,
      @required this.endTimeM});

  @override
  String toString() {
    print(
        'Category:$category Task:$task Priority:$priority Done:$done startTimeH:$startTimeH startTimeM:$startTimeM endTimeH:$endTimeH endTimeM:$endTimeM');
    return super.toString();
  }
}

class Plan with ChangeNotifier {
  final apiUrl = Config.apiUrl;
  String token;
  List<PlanItem> tempPlan;
  List<PlanItem> todaysPlanList;

  Map<String, dynamic> planConfig;

  static final planConfigInit = {
    "_isEditingPlan": false,
    "_isEditingTodaysPlan": false,
    "_isAutoGeneratedPlan": false,
    "_editingPlanId": '',
    "_todaysPlanId": '',
    "_todaysRemarks": [],
    "_todaysFeedback": 3.0,
    "_previousPlanRemarks": [],
    "_previousPlanFeedback": 3.0,
    "_completedTasks": 0.0,
    "_overallScore": '0.0',
    "_reqAccuracy": 'med'
  };

  Plan({this.token, this.tempPlan, this.todaysPlanList, this.planConfig});

  void initPlan() {
    if (!planConfig['_isEditingPlan']) tempPlan.clear();
  }

  void setEditingFalse() {
    print("set false");
    planConfig['_isEditingPlan'] = false;
    planConfig['_isAutoGeneratedPlan'] = false;
  }

  void setTodaysEditingPlanId() {
    planConfig['_editingPlanId'] = planConfig['_todaysPlanId'];
    planConfig['_isEditingTodaysPlan'] = true;
  }

  void setReqAccHigh() {
    planConfig['_reqAccuracy'] = 'high';
  }

  List<String> get todaysRemarks {
    return [...planConfig['_todaysRemarks']];
  }

  List<String> get previousPlanRemarks {
    return [...planConfig['_previousPlanRemarks']];
  }

  bool get isAutoGeneratedPlan {
    return planConfig['_isAutoGeneratedPlan'];
  }

  double get todaysFeedback {
    return planConfig['_todaysFeedback'];
  }

  double get previousPlanFeedback {
    return planConfig['_previousPlanFeedback'];
  }

  void _sortPlans(List<dynamic> planList) {
    planList.sort((planA, planB) {
      if (planB.startTimeH > planA.endTimeH)
        return -1;
      else if (planB.startTimeH == planA.endTimeH) {
        if (planB.startTimeM > planA.endTimeM)
          return -1;
        else if (planB.startTimeM < planA.endTimeM)
          return 1;
        else
          return 0;
      }

      return 1;
    });
  }

  void addPlanItem(PlanItem plan) {
    tempPlan.add(plan);
    _sortPlans(tempPlan);
    notifyListeners();
  }

  List<PlanItem> get plan {
    return [...tempPlan];
  }

  List<PlanItem> get todaysPlan {
    return [...todaysPlanList];
  }

  double get completedTasks {
    return planConfig['_completedTasks'];
  }

  String get overallScore {
    return planConfig['_overallScore'];
  }

  void editPlan(PlanItem oldPlan, PlanItem newPlan) {
    int index = tempPlan.indexOf(oldPlan);
    tempPlan[index] = newPlan;
    _sortPlans(tempPlan);
    notifyListeners();
  }

  Future<dynamic> savePlan() async {
    final url = Uri.parse('$apiUrl/plans');
    final editUrl =
        Uri.parse('$apiUrl/plans/update/${planConfig['_editingPlanId']}');
    print(editUrl);
    if (tempPlan.isEmpty) return throw ErrorDescription("Plan can't be empty!");
    List<dynamic> _data = [];
    tempPlan.forEach((item) {
      Map<String, dynamic> _object = {};

      _object['category'] = item.category;
      _object['task'] = item.task;
      _object['priority'] = item.priority;
      _object['done'] = item.done;
      _object['startTimeH'] = item.startTimeH;
      _object['startTimeM'] = item.startTimeM;
      _object['endTimeH'] = item.endTimeH;
      _object['endTimeM'] = item.endTimeM;

      _data.add(_object);
    });
    // print(json.encode(_data));
    try {
      final response = await http.post(
          planConfig['_isEditingPlan'] && !planConfig['_isAutoGeneratedPlan']
              ? editUrl
              : url,
          body: json.encode(_data),
          headers: {"x-auth-token": token, "Content-Type": "application/json"});

      var responseData = json.decode(response.body);
      if (responseData.containsKey('routine'))
        responseData = responseData['routine'][0];

      debugPrint(responseData.toString(), wrapWidth: 1024);
      if (response.statusCode != 200) {
        throw new HttpException(responseData['errors']);
      }

      if (planConfig['_isEditingTodaysPlan'] ||
          planConfig['_isAutoGeneratedPlan']) {
        todaysPlanList = [...tempPlan];
        planConfig['_isEditingTodaysPlan'] = false;
        planConfig['_todaysRemarks'] = responseData['remarks'];
      }
      tempPlan.clear();
      planConfig['_isEditingPlan'] = false;
      planConfig['_isAutoGeneratedPlan'] = false;

      double completedTasks = 0.0;
      for (var i = 0; i < responseData['plan'].length; i++) {
        if (responseData['plan'][i]['done']) completedTasks++;
      }
      planConfig['_completedTasks'] = completedTasks;
      planConfig['_overallScore'] =
          double.parse(responseData['score'].toString()).toString();

      getTodaysPlan();
      notifyListeners();
      return responseData;
    } catch (error) {
      throw error;
    }
  }

  Future<List<PlanItem>> getTodaysPlan() async {
    DateTime now = new DateTime.now();
    var formatter = new DateFormat('yyyy/MM/dd');
    String date = formatter.format(now);
    final url = Uri.parse('$apiUrl/plans/?date=$date');
    try {
      final response = await http.get(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );
      final responseData = json.decode(response.body);
      // print(responseData);
      if (response.statusCode == 200) {
        var plans = responseData['plan'];
        if (plans != null && plans is List<dynamic>) {
          todaysPlanList = [];
          plans.forEach((element) {
            if (Config.categories.contains(element['category']))
              todaysPlanList.add(
                PlanItem(
                    category: element['category'],
                    task: element['task'],
                    priority: element['priority'],
                    done: element['done'],
                    startTimeH: element['startTimeH'],
                    startTimeM: element['startTimeM'],
                    endTimeH: element['endTimeH'],
                    endTimeM: element['endTimeM']),
              );
          });

          _sortPlans(todaysPlanList);
          planConfig['_todaysPlanId'] = responseData['_id'];
          planConfig['_todaysRemarks'] = responseData['remarks'];
          planConfig['_todaysFeedback'] =
              double.parse(responseData['feedback']);
          double completedTasks = 0;
          for (var i = 0; i < todaysPlanList.length; i++) {
            if (todaysPlanList[i].done) completedTasks++;
          }
          planConfig['_completedTasks'] = completedTasks;
          planConfig['_overallScore'] = responseData['score'];
          // notifyListeners();
          // final timeRegex = RegExp("\d+:\d+");
          // _todaysRemarks.forEach((element) {
          //   element
          // });

        }
      } else {
        todaysPlanList = [];
      }

      return [...todaysPlanList];
    } catch (error) {
      throw error;
    }
  }

  Future<dynamic> getPreviousPlan(DateTime prevDate) async {
    DateTime now = prevDate;
    var formatter = DateFormat('yyyy/MM/dd');
    String date = formatter.format(now);
    final url = Uri.parse('$apiUrl/plans/?date=$date');
    try {
      final response = await http.get(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );
      final responseData = json.decode(response.body);
      debugPrint(responseData.toString(), wrapWidth: 1024);
      if (response.statusCode == 200) {
        List<PlanItem> planList = [];
        var plans = responseData['plan'];
        if (plans != null && plans is List<dynamic>) {
          plans.forEach((element) {
            if (Config.categories.contains(element['category']))
              planList.add(
                PlanItem(
                    category: element['category'],
                    task: element['task'],
                    priority: element['priority'],
                    done: element['done'],
                    startTimeH: element['startTimeH'],
                    startTimeM: element['startTimeM'],
                    endTimeH: element['endTimeH'],
                    endTimeM: element['endTimeM']),
              );
          });

          _sortPlans(planList);
          planConfig['_editingPlanId'] = responseData['_id'];
          planConfig['_previousPlanRemarks'] = responseData['remarks'];
          planConfig['_previousPlanFeedback'] =
              double.parse(responseData['feedback']);
          return planList;
        }
      } else {
        throw new HttpException(responseData['msg']);
      }
    } catch (error) {
      throw error;
    }
  }

  Future<void> deletePlan(bool isToday) async {
    final planId =
        isToday ? planConfig['_todaysPlanId'] : planConfig['_editingPlanId'];
    final url = Uri.parse('$apiUrl/plans/delete/$planId');

    try {
      final response = await http.delete(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );

      if (response.statusCode != 200) {
        throw HttpException('Something went wrong, unable to delete plan.');
      }
      if (isToday) todaysPlanList = [];
      notifyListeners();
    } catch (error) {
      throw error;
    }
  }

  Future<dynamic> getAutoGeneratedPlan() async {
    final url =
        Uri.parse('$apiUrl/predict/plans?reqAcc=${planConfig['_reqAccuracy']}');
    try {
      final response = await http.get(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );
      final responseData = json.decode(response.body);
      // print(responseData);
      if (response.statusCode == 200) {
        if (responseData.containsKey('plan')) {
          List<PlanItem> planList = [];
          var plans = responseData['plan'];
          if (plans != null && plans is List<dynamic>) {
            plans.forEach((element) {
              if (Config.categories.contains(element['category']))
                planList.add(
                  PlanItem(
                      category: element['category'],
                      task: element['task'],
                      priority: element['priority'],
                      done: element['done'],
                      startTimeH: element['startTimeH'],
                      startTimeM: element['startTimeM'],
                      endTimeH: element['endTimeH'],
                      endTimeM: element['endTimeM']),
                );
            });
          }
          _sortPlans(planList);
          planConfig['_isAutoGeneratedPlan'] = true;
          initEditCompletePlan(planList);
        }

        return responseData;
      } else {
        if (responseData.containsKey('msg')) {
          return responseData;
        } else
          throw new HttpException(responseData);
      }
    } catch (error) {
      throw error;
    } finally {
      planConfig['_reqAccuracy'] = 'med';
    }
  }

  Future<void> markPlan({bool isToday, PlanItem item, bool tick}) async {
    try {
      int index = tempPlan.indexOf(item);
      if (index >= 0) {
        PlanItem backup = item;

        PlanItem temp = PlanItem(
          category: item.category,
          task: item.task,
          priority: item.priority,
          done: tick,
          startTimeH: item.startTimeH,
          startTimeM: item.startTimeM,
          endTimeH: item.endTimeH,
          endTimeM: item.endTimeM,
        );
        tempPlan[index] = temp;
        if (isToday) {
          todaysPlanList = [...tempPlan];
          notifyListeners();
        }

        try {
          savePlan();
        } catch (err) {
          tempPlan[index] = backup;
          if (isToday) {
            todaysPlanList = [...tempPlan];
            notifyListeners();
          }

          throw Exception(
              'Sorry! Unable to perform this operation. Try again later.');
        }
      }
    } catch (error) {
      throw error;
    }
  }

  Future<dynamic> saveFeedback({DateTime date, double feedback}) async {
    DateTime now = date;
    var formatter = DateFormat('yyyy/MM/dd');
    String givenDate = formatter.format(now);
    final url = Uri.parse('$apiUrl/plans/feedback');
    try {
      final response = await http.post(url,
          headers: {
            "x-auth-token": token,
            "Content-Type": "application/json",
          },
          body: json.encode({"date": givenDate, "feedback": feedback}));
      final responseData = json.decode(response.body);
      debugPrint(responseData.toString(), wrapWidth: 1024);
      if (response.statusCode == 200) {
        if (givenDate == DateFormat('yyyy/MM/dd').format(DateTime.now())) {
          planConfig['_todaysFeedback'] = feedback;
        } else {
          planConfig['_previousPlanFeedback'] = feedback;
        }
        notifyListeners();
        return responseData['msg'];
      } else {
        throw new HttpException(responseData['msg']);
      }
    } catch (error) {
      throw error;
    }
  }

  Future<dynamic> getRearrangedPlan() async {
    final url = Uri.parse('$apiUrl/plans/rearrange');
    try {
      final response = await http.get(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );
      final responseData = json.decode(response.body);
      debugPrint(responseData.toString(), wrapWidth: 1024);
      if (response.statusCode == 200) {
        return responseData;
      } else {
        throw new HttpException(responseData['msg']);
      }
    } catch (error) {
      throw error;
    }
  }

  Future<dynamic> getStats({bool isWeek, String month}) async {
    String type = 'week';
    if (!isWeek) type = month;
    final url = Uri.parse('$apiUrl/plans/stats/$type');
    try {
      final response = await http.get(
        url,
        headers: {
          "x-auth-token": token,
          "Content-Type": "application/json",
        },
      );
      final responseData = json.decode(response.body);
      debugPrint(responseData.toString(), wrapWidth: 1024);
      if (response.statusCode == 200) {
        return responseData;
      } else {
        throw new HttpException(responseData['msg']);
      }
    } catch (error) {
      throw error;
    }
  }

  void initEditCompletePlan(List<PlanItem> plan) {
    tempPlan = [...plan];
    planConfig['_isEditingPlan'] = true;
    notifyListeners();
  }

  void deletePlanItem(PlanItem item) {
    int index = tempPlan.indexOf(item);
    tempPlan.removeAt(index);
    _sortPlans(tempPlan);
    notifyListeners();
  }

  TimeOfDay get getLastTimings {
    if (tempPlan.isEmpty) {
      return TimeOfDay(hour: 0, minute: 0);
    }

    return TimeOfDay(
        hour: tempPlan[tempPlan.length - 1].endTimeH,
        minute: tempPlan[tempPlan.length - 1].endTimeM);
  }

  void clear() {
    token = null;
    todaysPlanList = [];
    tempPlan = [];
    planConfig = planConfigInit;
    notifyListeners();
  }
}
